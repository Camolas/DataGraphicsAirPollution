<!--------------------------------------------------------------------------------
	
    Aplikacja three.js - 06 light-3
                        Swiatlo hemisferyczne
	
	
	P.Kowalczyk 2018.10

Zmiany:
wersja orginalna							P.K. 08/10/2018

-------------------------------------------------------------------------------->

<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>05 triangle-3</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>

		<script src="js/three.js"></script>
		<script>

            //zmienne na rotacje
            var rot = [0, 0, 0];
            var key = [];

            //obsluga klawiatury
            document.addEventListener("keydown", function(event) {key[event.keyCode] = true;});
            document.addEventListener("keyup", function(event) {key[event.keyCode] = false;});



			////////////////////////////
			//Tworzenie sceny, kamery, renderera
			//
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			//var renderer = new THREE.WebGLRenderer();
			var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            //renderer.setClearColor(new THREE.Color(0x404040));

			////////////////////////////
			//powiazanie renderera z <body>
			//
			document.body.appendChild( renderer.domElement );


			////////////////////////////
			//tworzymy swiatlo ambient
			var ambientLight = new THREE.AmbientLight( 0x808080 );
			scene.add(ambientLight);
			
			////////////////////////////
            //tworzymy swiatlo punktowe, kolor szary, intensywnosc 1, zasieg 100
			var light = new THREE.PointLight( 0x808080, 1, 100 );
			light.position.set( 0, 0, 30 );
			scene.add( light );

			////////////////////////////
            //tworzymy swiatlo hemisferyczne, kolor nieba niebieski, kolor gruntu bialy, intensywnosc 1
			var lightH = new THREE.HemisphereLight( 0x008000, 0xffffff, 1 );
			scene.add( lightH );

			////////////////////////////
            //Tworzenie geometrii
            //rownanie okregu
            //

            

            var cone1 = new THREE.Geometry( );
            cone1.vertices.push(new THREE.Vector3(0, 0, 2));
            addPointsToGeometry(16, cone1, "white", "rgb(100%, 50%, 10%)");

            cone1.computeFaceNormals ();
            //cone1.computeFlatVertexNormals ();


            var cone2 = cone1.clone();
            //var cone2 = new THREE.BoxGeometry( 2, 2, 2);

            //ok mozemy usunac z cone1 kolory wierzcholkow 
            //pozostawiajac jedynie kolory face'ow
            for(var i = 0; i < cone1.faces.length; i++){
                cone1.faces[i].vertexColors = [];
            }
            cone1.colorsNeedUpdate = true;

            var coneMesh = new THREE.Mesh( cone1, new THREE.MeshBasicMaterial( {vertexColors: THREE.FaceColors } )); 
            
            //var coneMesh2 = new THREE.Mesh( cone2, new THREE.MeshStandardMaterial(  ));
            //var coneMesh2 = new THREE.Mesh( cone2, new THREE.MeshStandardMaterial( {vertexColors: THREE.FaceColors } ));
            var coneMesh2 = new THREE.Mesh( cone2, new THREE.MeshStandardMaterial( {vertexColors: THREE.VertexColors} ));


            coneMesh.position.x = -2;
            coneMesh2.position.x = 2;
            coneMesh.rotation.y = Math.PI/2;
            coneMesh2.rotation.y = -Math.PI/2;

            var sandGlass = new THREE.Group();

            sandGlass.add(coneMesh);
            sandGlass.add(coneMesh2);

            scene.add( sandGlass );
            //scene.add( coneMesh2 );

            
            camera.position.z = 4;
            camera.lookAt(scene.position);


            //renderScene();
            animate();




            function renderScene(){

                sandGlass.rotation.x = rot[0];
                sandGlass.rotation.y = rot[1];
                sandGlass.rotation.z = rot[2];
                

                // camera.rotation.x = rot[0];
                // camera.rotation.y = rot[1];
                // camera.rotation.z = rot[2];

 			    renderer.render(scene, camera);
            }

			function animate() {
                requestAnimationFrame( animate );

                keyboard();
                
                if ( typeof animate.step == 'undefined' ) {
                    // It has not... perform the initialization
                    animate.step = 0.01;
                    animate.index = 0;

                }
                coneMesh2.rotation.x += 0.01;
                //coneMesh2.rotation.y += 0.01;
                //coneMesh2.rotation.z += 0.01;

                
                coneMesh2.position.x += animate.step;
                animate.index += animate.step;
                if(animate.index > 1 || animate.index < 0) animate.step = -animate.step;


				renderScene();
			};




            function addPointsToGeometry(number, geometry, c1, c2){
                for(var i = 0; i < number; i++){
                    var a = i * 2 * Math.PI / number;
                    geometry.vertices.push(new THREE.Vector3(Math.sin(a), Math.cos(a), 0)); 
                }   
        
                for(var i = 1; i <= number; i++){
                    var face;
                    var color;
                    if(i < number){
                        face = new THREE.Face3(0, i+1, i);
                    }
                    else{
                        face = new THREE.Face3(0, 1, i);
                    }

                    if(i & 1){
                        color = new THREE.Color(c1);
                    } 
                    else {
                        color = new THREE.Color(c2);
                    }
                    
                    
                    face.color.set(color);
                    for(var j = 0; j < 3; j++){
                        face.vertexColors.push(new THREE.Color(Math.random() * 0xffffff));
                    }
                    geometry.faces.push(face);
                }
   
            }

            function keyboard() {

                if (key['a'.charCodeAt(0)] || key['A'.charCodeAt(0)]) {
                    rot[1] -= 0.05;
                } 
                if (key['d'.charCodeAt(0)] || key['D'.charCodeAt(0)]) {
                    rot[1] += 0.05;
                } 
                if (key['w'.charCodeAt(0)] || key['W'.charCodeAt(0)]) {
                    rot[0] -= 0.05;
                } 
                if (key['s'.charCodeAt(0)] || key['S'.charCodeAt(0)]) {
                    rot[0] += 0.05;
                } 
                if (key['z'.charCodeAt(0)] || key['Z'.charCodeAt(0)]) {
                    rot[2] -= 0.05;
                } 
                if (key['x'.charCodeAt(0)] || key['X'.charCodeAt(0)]) {
                    rot[2] += 0.05;
                } 
                if (key[32]) {
                    rot[0] = rot[1] = rot[2] = 0;
                } 

            };


            


		</script>
	</body>
</html>