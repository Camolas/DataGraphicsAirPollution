<!--------------------------------------------------------------------------------
	
    Aplikacja three.js - 05 triangle-5
                        stozek z trojkatow z dnem
                        gorny stozek moze byc bez testu glebokosci
	
	
	P.Kowalczyk 2018.10

Zmiany:
wersja orginalna							P.K. 05/10/2018

-------------------------------------------------------------------------------->

<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>05 triangle-5</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>

		<script src="js/three.js"></script>
		<script>

            //zmienne na rotacje
            var rot = [0, 0, 0];

            //obsluga klawiatury
            document.addEventListener("keydown", onDocumentKeyDown, false);



			////////////////////////////
			//Tworzenie sceny, kamery, renderera
			//
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			//var renderer = new THREE.WebGLRenderer();
			var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor(new THREE.Color(0x404040));

			////////////////////////////
			//powiazanie renderera z <body>
			//
			document.body.appendChild( renderer.domElement );


			////////////////////////////
            //Tworzenie geometrii
            //rownanie okregu
            //
            var geometry1 = new THREE.Geometry( );
            geometry1.vertices.push(new THREE.Vector3(0, 0, 2));
            addPointsToGeometry(10, geometry1, "red", "green");
            var material1 = new THREE.MeshBasicMaterial( {vertexColors: THREE.FaceColors } );
            
            //ponizsze flagi kontroluja ktora strona trojkatow jest widoczna
            material1.side = THREE.DoubleSide;
            //material1.side = THREE.FrontSide;
            //material1.side = THREE.BackSide;
            //material1.depthTest = false;


            var triangles1 = new THREE.Mesh( geometry1, material1 );
            scene.add( triangles1 );

            var geometry2 = new THREE.Geometry( );
            geometry2.vertices.push(new THREE.Vector3(0, 0, 0));
            addPointsToGeometry(10, geometry2, "blue", "yellow");
            var material2 = new THREE.MeshBasicMaterial( {vertexColors: THREE.FaceColors } );
            
            //ponizsze flagi kontroluja ktora strona trojkatow jest widoczna
            material2.side = THREE.DoubleSide;
            //material2.side = THREE.FrontSide;
            //material2.side = THREE.BackSide;


             var triangles2 = new THREE.Mesh( geometry2, material2 );

            
            scene.add( triangles2 );

            
            camera.position.z = 3;
            camera.lookAt(scene.position);


            renderScene();




            function renderScene(){

                triangles1.rotation.x = rot[0];
                triangles1.rotation.y = rot[1];
                triangles1.rotation.z = rot[2];

                triangles2.rotation.x = rot[0];
                triangles2.rotation.y = rot[1];
                triangles2.rotation.z = rot[2];

                // camera.rotation.x = rot[0];
                // camera.rotation.y = rot[1];
                // camera.rotation.z = rot[2];

 			    renderer.render(scene, camera);
            }



            function addPointsToGeometry(number, geometry, c1, c2){
                for(var i = 0; i < number; i++){
                    var a = i * 2 * Math.PI / number;
                    geometry.vertices.push(new THREE.Vector3(Math.sin(a), Math.cos(a), 0));   
                }   
        
                for(var i = 1; i <= number; i++){
                    var face;
                    var color;
                    if(i < number){
                        face = new THREE.Face3(0, i+1, i);
                    }
                    else{
                        face = new THREE.Face3(0, 1, i);
                    }

                    if(i & 1){
                        color = new THREE.Color(c1);
                    } 
                    else 
                    {
                        color = new THREE.Color(c2);
                    }
                
                
                    face.color.set(color);
                    geometry.faces.push(face);
                }
   
            }

            function onDocumentKeyDown(event) {
                var key = event.which;
                /*const keyName = event.key;
                alert('keydown event\n\n' + 'key: ' + key);*/

                if (key == 'a'.charCodeAt(0) || key == 'A'.charCodeAt(0)) {
                    rot[1] -= 0.05;
                } 
                else if (key == 'd'.charCodeAt(0) || key == 'D'.charCodeAt(0)) {
                    rot[1] += 0.05;
                } 
                else if (key == 'w'.charCodeAt(0) || key == 'W'.charCodeAt(0)) {
                    rot[0] -= 0.05;
                } 
                else if (key == 's'.charCodeAt(0) || key == 'S'.charCodeAt(0)) {
                    rot[0] += 0.05;
                } 
                else if (key == 'z'.charCodeAt(0) || key == 'Z'.charCodeAt(0)) {
                    rot[2] -= 0.05;
                } 
                else if (key == 'x'.charCodeAt(0) || key == 'X'.charCodeAt(0)) {
                    rot[2] += 0.05;
                } 
                else if (key == 32) {
                    rot[0] = rot[1] = rot[2] = 0;
                } 

                renderScene();
            };


            


		</script>
	</body>
</html>