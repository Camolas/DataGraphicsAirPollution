<!--------------------------------------------------------------------------------
	
    Aplikacja three.js - 07 geometries-1
                        Porownanie podstawowych geometrii
	
	
	P.Kowalczyk 2018.10

Zmiany:
wersja orginalna							P.K. 08/10/2018

-------------------------------------------------------------------------------->

<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>07 geometries-1</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>

        <script src="js/three.js"></script>
        <script src="js/ParametricGeometries.js"></script> 
		<script>

            //zmienne na rotacje
            var rot = [0, 0, 0];
            var key = [];
            var objects = new THREE.Group();

            //obsluga klawiatury
            document.addEventListener("keydown", function(event) {key[event.keyCode] = true;});
            document.addEventListener("keyup", function(event) {key[event.keyCode] = false;});



			////////////////////////////
			//Tworzenie sceny, kamery, renderera
			//
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

			//var renderer = new THREE.WebGLRenderer();
			var renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            //renderer.setClearColor(new THREE.Color(0x404040));

			////////////////////////////
			//powiazanie renderera z <body>
			//
			document.body.appendChild( renderer.domElement );


			////////////////////////////
			//tworzymy swiatlo ambient
			var ambientLight = new THREE.AmbientLight( 0x808080 );
			scene.add(ambientLight);
			
			////////////////////////////
            //tworzymy swiatlo punktowe, kolor szary, intensywnosc 1, zasieg 100
			var light = new THREE.PointLight( 0x808080, 1, 100 );
			light.position.set( 0, 0, 30 );
			//scene.add( light );

			////////////////////////////
            //tworzymy swiatlo hemisferyczne, kolor nieba niebieski, kolor gruntu bialy, intensywnosc 1
			var lightH = new THREE.HemisphereLight( 0x008000, 0xffffff, 1 );
			scene.add( lightH );

			////////////////////////////
            //Tworzenie geometrii
            //
            //

            //BoxGeometry(wymiarX, wymiarY, wymiarZ)
            var cube = new THREE.Mesh( new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            cube.position.x = -5;
            cube. position.y = 3;
            objects.add(cube);
  
            //CircleGeometry(promien, liczba segmentow)
            var circle = new THREE.Mesh( new THREE.CircleGeometry(1,8), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            circle.position.x = -3;
            circle. position.y = 3;
            objects.add(circle);

            //ConeGeometry(promien, wysokosc, liczba segmentow)
            var cone = new THREE.Mesh( new THREE.ConeGeometry( 1, 1, 6 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            cone.position.x = -1;
            cone. position.y = 3;
            objects.add(cone);

            //CylinderGeometry(promienGora, promienDol, wysokosc, liczba segmentow)
            var cylinder = new THREE.Mesh( new THREE.CylinderGeometry( 1, 0.8, 1, 6 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            cylinder.position.x = 1;
            cylinder. position.y = 3;
            objects.add(cylinder);

            //DodecahedronGeometry(promien, czyDodatkoweWierzcholki )
            var dodecahedron = new THREE.Mesh( new THREE.DodecahedronGeometry( 1, 0 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            dodecahedron.position.x = 3;
            dodecahedron. position.y = 3;
            objects.add(dodecahedron);
            
            //DodecahedronGeometry(promien, czyDodatkoweWierzcholki )
            var dodecahedron1 = new THREE.Mesh( new THREE.DodecahedronGeometry( 1, 1 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            dodecahedron1.position.x = 5;
            dodecahedron1. position.y = 3;
            objects.add(dodecahedron1);

            //EdgesGeometry( geometry )
            var edges = new THREE.LineSegments( new THREE.EdgesGeometry( new THREE.BoxGeometry(1,1,1) ), new THREE.LineBasicMaterial( {color: Math.random() *0xffffff } )); 
            edges.position.x = -5;
            edges. position.y = 1;
            objects.add(edges);

            //WireframeGeometry( geometry )
            var wire = new THREE.LineSegments( new THREE.WireframeGeometry( new THREE.BoxGeometry(1,1,1) ), new THREE.LineBasicMaterial( {color: Math.random() *0xffffff } )); 
            wire.position.x = -3;
            wire. position.y = 1;
            wire.material.depthTest = false;
            wire.material.opacity = 0.25;
            wire.material.transparent = true;
            objects.add(wire);

            //IcosahedronGeometry(promien, czyDodatkoweWierzcholki )
            var icosa = new THREE.Mesh( new THREE.IcosahedronGeometry( 1, 0 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            icosa.position.x = -1;
            icosa. position.y = 1;
            objects.add(icosa);

            //OctahedronGeometry(promien, czyDodatkoweWierzcholki )
            var octah = new THREE.Mesh( new THREE.OctahedronGeometry( 1, 0 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            octah.position.x = 1;
            octah. position.y = 1;
            objects.add(octah);

            //PlaneGeometry(wysokosc, szerokosc, segmentow )
            var plane = new THREE.Mesh( new THREE.PlaneGeometry( 1, 1, 3 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            plane.position.x = 3;
            plane. position.y = 1;
            objects.add(plane);

            //RingGeometry(R_wewnetrzny, R_zewnetrzny, segmentow )
            var ring = new THREE.Mesh( new THREE.RingGeometry( 0.5, 1, 7 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            ring.position.x = 5;
            ring. position.y = 1;
            objects.add(ring);

            //TetrahedronGeometry(promien, czyDodatkoweWierzcholki )
            var tetra = new THREE.Mesh( new THREE.TetrahedronGeometry( 1, 0 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            tetra.position.x = -5;
            tetra. position.y = -1;
            objects.add(tetra);

            //TorusGeometry(promien, promien_tuby, segmentow )
            var torus = new THREE.Mesh( new THREE.TorusGeometry( 0.7, 0.4, 7 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            torus.position.x = -3;
            torus. position.y = -1;
            objects.add(torus);

            //TorusKnotGeometry(promien, promien_tuby, segmentow )
            var torusKnot = new THREE.Mesh( new THREE.TorusKnotGeometry( 0.7, 0.1, 25 ), new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            torusKnot.position.x = -1;
            torusKnot. position.y = -1;
            objects.add(torusKnot);

            //ParametricBufferGeometry(funkcja, segmentow, stakow )
            //Klein
            var klein = new THREE.Mesh( new THREE.ParametricBufferGeometry( THREE.ParametricGeometries.klein, 20, 20 ), 
                                        new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            klein.position.x = 1;
            klein. position.y = -1;
            klein.scale.multiplyScalar( 0.1 ); 
            objects.add(klein);

            //ParametricBufferGeometry(funkcja, segmentow, stakow )
            //mobius
            var mobius = new THREE.Mesh( new THREE.ParametricBufferGeometry( THREE.ParametricGeometries.mobius, 20, 20 ), 
                                        new THREE.MeshStandardMaterial( {color: Math.random() *0xffffff } )); 
            mobius.position.x = 3;
            mobius. position.y = -1;
            mobius.scale.multiplyScalar( 0.5 ); 
            objects.add(mobius);

            scene.add( objects );
           
            
            camera.position.z = 8;
            camera.lookAt(scene.position);


            //renderScene();
            animate();




            function renderScene(){

                objects.rotation.x = rot[0];
                objects.rotation.y = rot[1];
                objects.rotation.z = rot[2];
                

                // camera.rotation.x = rot[0];
                // camera.rotation.y = rot[1];
                // camera.rotation.z = rot[2];

 			    renderer.render(scene, camera);
            }

			function animate() {
                requestAnimationFrame( animate );

                keyboard();
                
                if ( typeof animate.step == 'undefined' ) {
                    // It has not... perform the initialization
                    animate.step = 0.01;
                    animate.index = 0;

                }

                // for(var i = 0; i < objects.children.length; i++){
                //     objects.children[i].rotation.x += Math.random() * 0.01;
                //     objects.children[i].rotation.y += Math.random() * 0.01;
                //     objects.children[i].rotation.z += Math.random() * 0.01;
                // }
               objects.traverse (function(obj){
                    obj.rotation.x += Math.random() * 0.01;
                    obj.rotation.y += Math.random() * 0.01;
                    obj.rotation.z += Math.random() * 0.01;
                  
               });
                //coneMesh2.rotation.y += 0.01;
                //coneMesh2.rotation.z += 0.01;

                
                //cube.position.x += animate.step;
                animate.index += animate.step;
                if(animate.index > 1 || animate.index < 0) animate.step = -animate.step;


				renderScene();
			};





            function keyboard() {

                if (key['a'.charCodeAt(0)] || key['A'.charCodeAt(0)]) {
                    rot[1] -= 0.05;
                } 
                if (key['d'.charCodeAt(0)] || key['D'.charCodeAt(0)]) {
                    rot[1] += 0.05;
                } 
                if (key['w'.charCodeAt(0)] || key['W'.charCodeAt(0)]) {
                    rot[0] -= 0.05;
                } 
                if (key['s'.charCodeAt(0)] || key['S'.charCodeAt(0)]) {
                    rot[0] += 0.05;
                } 
                if (key['z'.charCodeAt(0)] || key['Z'.charCodeAt(0)]) {
                    rot[2] -= 0.05;
                } 
                if (key['x'.charCodeAt(0)] || key['X'.charCodeAt(0)]) {
                    rot[2] += 0.05;
                } 
                if (key[32]) {
                    rot[0] = rot[1] = rot[2] = 0;
                } 

            };


            


		</script>
	</body>
</html>